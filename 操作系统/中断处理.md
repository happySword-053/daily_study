中断处理大致可以分为以下几个阶段，下面以 x86 架构与典型的可编程中断控制器（PIC/APIC）为例，说明从中断发生到返回的完整流程：

1. **中断请求（Interrupt Request）**  
    外部设备（或内部异常／软件中断）在总线上发出中断请求信号（INTR，或 APIC 的消息信号）。
    
2. **当前指令完成**  
    CPU 在当前已开始执行的指令完成后才会响应中断；这保证了指令的原子性。
    
3. **禁止进一步中断（可选）**  
    在进入中断处理前，CPU 通常会在标志寄存器中清除中断使能位（IF），以防止中断嵌套，除非 ISR 明确允许嵌套。
    
4. **保存上下文（Context Save）**  
    CPU 自动将以下信息压入内核栈（或 ISR 专用栈）：
    
    - 标志寄存器（EFLAGS/RFLAGS）
        
    - 返回地址（当前指令的下一条指令的 CS:IP 或 RIP）
        
    - （在某些情况下）错误代码或异常编号
        
5. **查中断向量表（IDT）**  
    CPU 读取中断向量号（由 PIC 在总线协议或由硬件异常固定），并使用该向量号在中断描述符表（IDT）中查找对应的门描述符（Gate Descriptor）。
    
    - 对于外部中断（IRQ0~~IRQ15），PIC 会先将物理 IRQ 编号映射到 IDT 向量号范围（通常是32~~47）。
        
    - 对于软件中断（INT n），直接使用指令中给定的向量号。
        
6. **切换栈（如果需要）**  
    如果当前处于用户态（CPL=3），而中断处理要求更高特权级（CPL=0），CPU 会根据当前任务的 TSS（任务状态段）中保存的内核栈指针自动切换到内核栈。
    
7. **跳转到 ISR（Interrupt Service Routine）**  
    CPU 将 CS/RIP（或 CS:IP）加载为 IDT 描述符中指定的段选择子和偏移地址，开始执行中断服务例程。
    
8. **中断服务例程执行**  
    ISR 完成以下工作：
    
    - 确认并清除中断源（向设备寄送 ACK，或对可编程中断控制器发 EOI/end-of-interrupt）。
        
    - 保存更多现场（如果 ISR 很长或会调用函数，可手动将通用寄存器 PUSH 到栈）。
        
    - 执行业务逻辑：驱动程序处理数据、唤醒等待进程、记录日志等。
        
    - 恢复手动保存的寄存器（如果有）。
        
9. **发送 EOI（End Of Interrupt）**  
    ISR 通常在访问 PIC（或 APIC）时，写入特定寄存器向中断控制器通知中断处理完成，使其可以接收并转发新的中断。
    
10. **恢复上下文（Context Restore）**  
    CPU 执行 `IRET`（或 `IRETD`/`IRETQ`），自动从栈上弹出：
    
    - 返回地址（CS:IP／RIP）
        
    - 原先的标志寄存器值（EFLAGS/RFLAGS）
        
    - （若有）错误码或异常编号
        
11. **重新开启中断（可选）**  
    如果 ISR 在退出前没有重新设置 IF，则 `IRET` 会恢复到进入中断前的 IF 状态；否则中断继续被禁止。
    
12. **返回并继续执行**  
    CPU 跳回到中断发生处的下一条指令，继续正常执行程序。
    

---

### 图示流程

pgsql

复制编辑

`设备/软件发中断 ──▶ INTR/INT n 信号       │       ▼     完成当前指令       │       ▼ 清除 IF（禁止中断）       │       ▼ 保存 EFLAGS, CS:IP[to stack]       │       ▼ 查 IDT 向量 → 得到 ISR 地址       │       ▼ (如需) 切换至内核栈       │       ▼     跳转执行 ISR       │       ▼     处理并清除中断源       │       ▼    向 PIC/APIC 发 EOI       │       ▼     IRET 恢复现场       │       ▼ (恢复 IF) → 继续执行原程序`