TCP的[粘包](https://zhida.zhihu.com/search?content_id=167290733&content_type=Article&match_order=1&q=%E7%B2%98%E5%8C%85&zhida_source=entity)和[拆包](https://zhida.zhihu.com/search?content_id=167290733&content_type=Article&match_order=1&q=%E6%8B%86%E5%8C%85&zhida_source=entity)问题往往出现在基于[TCP协议](https://zhida.zhihu.com/search?content_id=167290733&content_type=Article&match_order=1&q=TCP%E5%8D%8F%E8%AE%AE&zhida_source=entity)的通讯中，比如RPC框架、[Netty](https://zhida.zhihu.com/search?content_id=167290733&content_type=Article&match_order=1&q=Netty&zhida_source=entity)等。如果你的简历中写了类似的技术或者你所面试的公司使用了相关的技术，被问到该面试的几率会非常高。

今天这篇文章就带大家详细了解一下TCP的粘包和拆包以及解决方案。

### 什么是粘包？

在学习粘包之前，先纠正一下读音，很多视频教程中将“粘”读作“nián”。经过调研，个人更倾向于读“zhān bāo”。

如果在百度百科上搜索“粘包”，对应的读音便是“zhān bāo”，语义解释为：网络技术术语。指TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

TCP是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。

### 为什么UDP没有粘包？

粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。

### 粘包拆包发生场景

因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。

如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。

如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。

关于粘包和拆包可以参考下图的几种情况：
![[Pasted image 20250225145707.png]]
上图中演示了以下几种情况：

- 正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；
- 粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；
- 拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；
- 拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。

### 常见的解决方案

对于粘包和拆包问题，常见的解决方案有四种：

- 发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；
- 发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；
- 将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；
- 通过自定义协议进行粘包和拆包的处理。