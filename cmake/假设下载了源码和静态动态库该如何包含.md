### 1. 查找头文件和库文件目录

首先，你需要告诉 CMake 你的头文件和库文件在哪里。最推荐的方法是使用 **CMake 变量** 来存储这些路径，方便管理和修改。

假设你的第三方库（比如 `MyLib`）下载后解压到了一个目录，结构如下：

```
/path/to/MyLib_extracted_folder/
├── include/
│   └── mylib.h
└── lib/
    ├── libmylib.a    # 静态库
    └── libmylib.so   # 动态库 (Linux)
    └── mylib.dll     # 动态库 (Windows)
    └── mylib.lib     # 导入库 (Windows)
```

你可以在 `CMakeLists.txt` 文件中定义变量来指向这些路径：



```CMake
# 定义第三方库的根目录。
# 推荐使用绝对路径，或者相对于你的项目根目录的路径。
set(MYLIB_ROOT_DIR "/path/to/MyLib_extracted_folder")

# 拼接出头文件和库文件目录
set(MYLIB_INCLUDE_DIR "${MYLIB_ROOT_DIR}/include")
set(MYLIB_LIB_DIR "${MYLIB_ROOT_DIR}/lib")

# 打印路径，方便调试
message(STATUS "MyLib include directory: ${MYLIB_INCLUDE_DIR}")
message(STATUS "MyLib library directory: ${MYLIB_LIB_DIR}")
```

这样，你可以轻松地在不同的机器或环境中修改 `MYLIB_ROOT_DIR` 变量，而不需要修改下面的命令。

---

### 2. 将路径添加到你的目标

接下来，你需要使用 **`target_include_directories`** 和 **`target_link_libraries`** 这两个现代 CMake 命令，将刚才定义的路径应用到你的可执行文件或库目标上。

假设你有一个可执行文件目标 `MyProgram`：



```CMake
# 假设你已经创建了可执行文件目标
add_executable(MyProgram main.cpp)

# 1. 添加头文件路径
# PRIVATE 表示只有 MyProgram 自己需要这个头文件路径
target_include_directories(MyProgram PRIVATE ${MYLIB_INCLUDE_DIR})

# 2. 链接库文件
# 你需要链接的是库的名称（mylib），CMake 会自动根据平台查找 libmylib.a 或 mylib.lib
# PRIVATE 表示只有 MyProgram 需要链接这个库
target_link_libraries(MyProgram PRIVATE "${MYLIB_LIB_DIR}/mylib")

# 另外一种更灵活的链接方式：使用 find_library()
# find_library 会在 MYLIB_LIB_DIR 目录下查找名为 "mylib" 的库
find_library(MYLIB_LIB
             NAMES mylib
             PATHS ${MYLIB_LIB_DIR}
             NO_DEFAULT_PATH) # 这一行很重要，告诉 CMake 只在指定路径下找，不要去系统默认路径找
             
if(MYLIB_LIB)
    message(STATUS "Found MyLib library: ${MYLIB_LIB}")
    target_link_libraries(MyProgram PRIVATE ${MYLIB_LIB})
else()
    message(FATAL_ERROR "Could not find mylib library in ${MYLIB_LIB_DIR}")
endif()

```

#### 解释：

- **`target_include_directories(MyProgram PRIVATE ...)`**: 这个命令告诉编译器，在编译 `MyProgram` 时需要到 `${MYLIB_INCLUDE_DIR}` 目录下查找头文件。
    
- **`target_link_libraries(MyProgram PRIVATE ...)`**: 这个命令告诉链接器，在链接 `MyProgram` 时需要链接 `mylib` 这个库。
    
    - **指定完整路径**：`"${MYLIB_LIB_DIR}/mylib"` 这种方式是最直接的，CMake 会根据这个路径找到对应的库文件。
        
    - **使用 `find_library()`**：这是一种更健壮的方法，尤其是在库文件名有后缀或前缀的情况下。`find_library` 会在指定的 `PATHS` 中查找 `libmylib.so`、`mylib.lib` 等，并将找到的完整路径存储在 `MYLIB_LIB` 变量中，然后你再链接这个变量。
        

---

### 3. 如何选择静态库或动态库？

如果你同时拥有静态库和动态库，CMake 默认会优先链接动态库。如果你想强制使用静态库，可以在链接命令中指定：



```CMake
# 强制链接静态库
set_target_properties(MyProgram PROPERTIES LINK_FLAGS "-Wl,-Bstatic -lmylib -Wl,-Bdynamic") # Linux/macOS
# 或者更简单的
set_property(TARGET MyProgram APPEND PROPERTY LINK_OPTIONS "-Wl,--whole-archive ${MYLIB_LIB} -Wl,--no-whole-archive") # Linux/macOS
```

然而，最好的方式是使用 **`find_library()`** 并指定库的类型：


```CMake

# 强制查找静态库
find_library(MYLIB_STATIC_LIB
             NAMES mylib
             PATHS ${MYLIB_LIB_DIR}
             NO_DEFAULT_PATH
             # 指定查找类型
             # CMAKE_FIND_LIBRARY_SUFFIXES ".a"
             )
# 然后链接找到的静态库
target_link_libraries(MyProgram PRIVATE ${MYLIB_STATIC_LIB})
```