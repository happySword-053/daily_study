### Raft 算法的核心思想

Raft 算法的目标是提供一个易于理解和实现的一致性算法，它通过**领导者选举**和**日志复制**这两个核心机制来保证分布式集群中数据的一致性。

与 Paxos 算法中复杂的提议者、接受者、学习者等角色不同，Raft 算法的角色（或者说节点的状态）更加直观：

- **领导者 (Leader)**：在任何一个时间点，Raft 集群中通常**只有一个领导者**。所有客户端的写请求都必须先发送给领导者，领导者会将这些操作记录到自己的**日志**中，并负责将日志条目复制给所有其他节点（追随者）。领导者也负责发送心跳包来维护自己的领导地位。
- **追随者 (Follower)**：集群中绝大多数节点都是追随者。它们被动地接收来自领导者的心跳包和日志复制请求。如果追随者在一定时间内没有收到领导者的心跳，它们就会认为领导者可能已经失效，并转变为候选人状态，发起新的选举。
- **候选人 (Candidate)**：当追随者认为领导者失效时，它会将自己提升为候选人，并向集群中的其他节点发送**请求投票 (RequestVote) RPC**（远程过程调用）来争取成为新的领导者。

---

### Raft 算法的详细流程

Raft 算法的流程主要围绕着两个阶段展开：**领导者选举**和**日志复制**。

#### 1. 领导者选举

领导者选举是 Raft 算法的起点，它确保了在任何时刻，集群中只有一个领导者来处理客户端请求并协调数据同步。

- **初始状态**：所有节点都是**追随者**。
- **超时触发选举**：每个追随者都有一个随机的**选举超时时间**（通常在 150ms 到 300ms 之间）。如果在选举超时时间内，追随者没有收到来自领导者（或候选人）的心跳包，它就会认为当前的领导者可能已经挂了，或者还没有领导者，于是它会将自己的状态切换为**候选人**。
- **发起投票**：
    - 成为候选人后，它会首先**给自己投一票**。
    - 然后，它会增加自己的**当前任期号 (Current Term)**。任期号是 Raft 中的一个逻辑时钟，每次选举都会增加。
    - 接着，它向集群中的所有其他节点发送 **请求投票 RPC**。
- **投票响应**：
    - 其他节点收到请求投票 RPC 后，会根据一些规则来决定是否给该候选人投票：
        - **任期号检查**：如果请求投票的候选人的任期号小于自己的当前任期号，则拒绝投票。
        - **首次投票原则**：在一个给定的任期内，每个追随者只会给**第一个**向它请求投票的候选人投票（这避免了多个候选人同时竞争导致的死锁）。
        - **日志完整性检查**：这是非常关键的一点！追随者只会投票给那些**日志至少和自己一样新（或更完整）**的候选人。这里的“新”指的是日志的最后一个条目的任期号更大，如果任期号相同，则看日志的长度。这个规则保证了被选出的领导者一定拥有所有已提交的日志。
- **赢得选举**：
    - 如果一个候选人收到了**集群中大多数节点（N/2 + 1）的投票**，那么它就成功赢得了选举，并立即成为**领导者**。
    - 成为领导者后，它会立即向所有追随者发送**心跳包**，以宣示自己的领导地位并阻止其他节点发起新的选举。
- **选举失败**：
    - 如果一个候选人未能赢得多数票（比如票数不足，或者有其他节点赢得了选举），它会退回到**追随者**状态。
    - 如果多个候选人同时发起选举，可能导致没有任何一个候选人赢得多数票，这被称为**分裂投票 (Split Vote)**。Raft 通过随机化选举超时时间来减少分裂投票的概率。如果发生分裂投票，节点会等待新的随机超时时间，然后再次发起选举。

---

#### 2. 日志复制

一旦领导者被选举出来，它就开始负责处理所有客户端的写请求，并通过日志复制来将数据同步到其他节点，确保数据的一致性。

- **客户端请求**：所有的客户端写请求都首先发送给**领导者**。
- **追加日志条目**：领导者接收到客户端请求后，会将这个操作（比如“将变量X设置为Y”）作为一个**日志条目**，追加到自己的日志中。每个日志条目都有一个**任期号**和**索引**。
- **发送追加日志 RPC**：领导者会并发地向所有**追随者**发送 **追加日志 (AppendEntries) RPC**。这些 RPC 中包含了最新的日志条目，以及一些元数据（比如领导者的任期号、前一个日志条目的索引和任期号，用于一致性检查）。
- **追随者响应**：
    - 追随者收到追加日志 RPC 后，会进行一致性检查：它会检查 RPC 中指定的前一个日志条目是否与自己日志中对应位置的条目匹配（索引和任期号都相同）。
    - 如果匹配，追随者就会将新的日志条目追加到自己的日志中，并回复领导者成功。
    - 如果不匹配（表示追随者的日志与领导者不一致），追随者会拒绝这个 RPC，并告知领导者自己的日志中冲突的索引。
- **日志一致性**：当追随者日志与领导者不一致时，领导者会进行**日志回溯**。领导者会维护一个 `nextIndex` 数组，记录了发送给每个追随者的下一个日志条目的索引。如果追随者拒绝了追加日志 RPC，领导者会递减对应的 `nextIndex`，并重试发送，直到找到一个匹配的日志条目。这个过程会一直进行，直到追随者的日志与领导者的日志完全一致。
- **提交日志条目**：
    - 当一个日志条目被**多数节点（包括领导者自己）成功复制**后，领导者就会将这个日志条目标记为**已提交 (Committed)**。
    - 一旦日志条目被提交，就意味着这个操作是安全的，即使领导者宕机，这个操作也不会丢失，因为它已经被多数节点持久化了。
    - 领导者会将已提交的最高日志索引通过心跳包或下一个追加日志 RPC 告知追随者。追随者收到后，也会将自己的日志相应地标记为已提交。
- **应用到状态机**：所有已提交的日志条目最终都会被**应用到状态机 (State Machine)**。状态机就是存储系统实际数据的逻辑，比如一个键值对存储的“状态”。只有当日志条目被应用到状态机后，它才能被客户端读取到。

---

### Raft 算法的安全性特性

Raft 通过严格的规则保证了数据的一致性和系统的可靠性：

- **选举安全性**：在一个给定任期内，最多只有一个领导者被选举出来。
- **领导者只增选拥有最新日志的节点**：确保了领导者拥有所有已提交的日志条目。
- **已提交的日志条目不会回滚**：一旦一个日志条目被提交，它就会永久存在，不会被删除或修改。
- **领导者完整性**：领导者拥有所有已提交的日志条目。