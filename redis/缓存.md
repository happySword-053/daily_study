**更新缓存**
**更新策略**
缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。
1、Cache Aside Pattern（最常用）
由缓存的调用者在更新数据库同时更新缓存
2、Read/Write Through Pattern
缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务无需关注一致性问题。但这种服务的成本肯定是很高的。
3、Write Behind Caching Pattern
调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致。
比如我们一直对缓存进行更新，更新10次以后轮到这个线程工作，就维护一下数据库的数据为更新10次后的数据，中途的其他9次更新操作根本不重要，这样的性能显然是很高的。
这种方式当然也有很大问题，比如长期的数据不一致、缓存宕机造成的严重后果等。

**但是我们会引发两种更新策略**：
- 先写数据库，再删除缓存
- 写删除缓存，再写数据库

### ** 两种顺序的对比**
- **风险** ：
    - 如果在 `redis.delete` 和 `db.update` 之间发生以下情况，缓存会被重新填充旧数据：
        
        1. 线程 A 删除缓存。
        2. 线程 B 查询数据，缓存缺失，从数据库读取旧值并写入缓存。
        3. 线程 A 完成数据库更新。
        
    - 结果：缓存中是旧数据，数据库中是新数据，**不一致窗口长期存在** 。
#### **方案 2：先更新数据库，再删除缓存**
- **优势** ：
    - 数据库更新完成后，即使缓存删除失败，后续查询会因缓存缺失而从数据库加载最新数据（**最终一致性** ）。
    - 即使在 `db.update` 和 `redis.delete` 之间有查询请求，缓存中的旧数据会在极短时间内被删除，**不一致窗口极短** 。

### **1. 缓存雪崩（Cache Avalanche）**

#### **定义**

大量缓存数据在同一时间段内集中失效，导致请求直接穿透到数据库，引发数据库负载骤增甚至崩溃。

#### **发生原因**

- 缓存的过期时间设置相同（例如所有缓存都设置 `EX 3600`）。
- Redis 宕机或大规模数据失效（如重启后未持久化）。

#### **示例场景**

- **电商大促** ：假设所有商品缓存都设置为 1 小时过期，1 小时后所有用户请求同时访问数据库，导致数据库崩溃。

#### **解决方案**

- **分散过期时间** ：  
    在基础过期时间上增加随机值（如 `EX 3600 + random(0, 600)`）：
    
    # 设置商品缓存时，过期时间随机 1~1.5 小时
    
    
- **多级缓存** ：  
    本地缓存（如 Guava Cache） + Redis 缓存，降低 Redis 压力。
    
- **熔断降级** ：  
    当数据库压力过高时，触发熔断机制，返回默认值（如“稍后再试”）。
    

---

### **2. 缓存击穿（Cache Breakdown）**

#### **定义**

某个热点数据的缓存失效后，大量并发请求直接访问数据库，导致数据库压力骤增。

#### **发生原因**

- 热点数据（如秒杀商品）的缓存过期。
- 高并发请求同时查询该数据。

#### **示例场景**

- **秒杀活动** ：某商品 ID=1001 的缓存过期，1 万用户同时请求购买，直接打爆数据库。

#### **解决方案**

- **互斥锁（Mutex）** ：  
    只允许一个线程重建缓存，其他线程等待：
    
    # 获取分布式锁
    
    # 等待锁释放后重试
    

    
- **逻辑过期时间** ：  
    缓存永不过期，但在值中存储逻辑过期时间，通过后台线程异步更新：
    
    
    # 缓存结构：{"data": "...", "expire_time": "2023-10-01 12:00:00"}
    
    def get_product(product_id):
    
    cache = redis.get(product_id)
    
    if cache and cache['expire_time'] > now():
    
    return cache['data']
    
    else:
    
    # 后台线程异步更新缓存
    
    update_cache_async(product_id)
    
    return db.query(product_id)
    

---

### **3. 缓存穿透（Cache Penetration）**

#### **定义**

查询不存在的数据（如 ID=-1 的商品），请求绕过缓存直接访问数据库，导致数据库压力增大。

#### **发生原因**

- 恶意攻击：频繁查询不存在的 ID。
- 业务逻辑缺陷：未校验参数合法性。

#### **示例场景**

- **恶意请求** ：攻击者不断查询 ID=999999（不存在的商品），每次请求都打到数据库。

#### **解决方案**

- **缓存空值** ：  

- **布隆过滤器（Bloom Filter）** ：  
    
    # 正常查询缓存和数据库