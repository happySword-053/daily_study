## 一、内置类型成员（int、double、指针……）

假设有：

cpp

复制编辑

`struct S {     int    x;     double y;     int*   p;     S() { /* 没有在构造函数列表或体内对 x、y、p 初始化 */ } };`

1. **Default‑初始化（只调用构造函数，不做额外赋值）**
    
    - 当对象通过 `S s;`（无括号）或 `new S;` 创建时，被视为 default‑初始化：
        
        - **内置类型成员** `x, y, p` 都 **保持“未定义/不确定（indeterminate）”值**。
            
        - 访问它们（读或写依赖旧值）都是未定义行为。
            
2. **Value‑初始化（带空括号或花括号）**
    
    - 当对象通过 `S s{};` 或 `new S();` 创建时，被视为 value‑初始化：
        
        - 如果有用户自定义默认构造函数（如上例 `S()`），则只执行构造函数体，**内置成员仍不初始化**，依然不确定。
            
        - 如果没有显式定义构造函数，则编译器会生成一个“隐式默认构造”，此时 value‑初始化会先 **将内置成员全部 **零初始化**（zero‑init），再调用（空）构造函数，结果就是 `x==0, y==0.0, p==nullptr`。
            

cpp

复制编辑

`struct T { int x; }; // T t1;    // default‑init → x 不定 // T t2{};  // value‑init → x == 0`

---

## 二、类类型成员（用户自定义类型）

cpp

复制编辑

`struct A {    int v;    A() : v(42) {}    // 默认构造将 v 初始化为 42 };  struct B {   A a;             // 类成员   B() { /* 没写 a(...) */ } };`

- **无论 default‑init 还是 value‑init**，**只要存在默认构造函数**，编译器都必须在进入 `B()` 体之前**调用 `A::A()`**，所以 `a.v` 总是被初始化为 42。
    
- 换言之，**类类型成员永远按它们的构造函数走**，不会留“未初始化”状态。
    

---

## 三、`static`（包括静态数据成员和局部 static 变量）

所有静态存储期（static storage duration）的对象，**在程序开始或动态初始化前**，都要先做一次 **零初始化**（zero initialization），再进行动态初始化（如果有）。

cpp

复制编辑

`struct C {   int     x;            // 普通成员   static int y;         // 静态数据成员   static A   a_static;  // 静态类成员 };  int C::y;               // 未在定义处赋值 → y 在启动时先被 zero‑init（y==0） A   C::a_static;        // 先 zero‑init（对对象而言把内存清零），再调用 A::A() → a_static.v == 42`

- **`static` 内置成员**（如 `int C::y;`）保证在任何使用前已被初始化为 0。
    
- **`static` 类成员** 先“全部字节清 0”（对应内置字段都是 0、指针 null），然后再调用它的构造函数。
    

同理，函数内的 `static T foo;` 也是如此，且在首轮执行到该声明时做动态初始化（thread‑safe，从 C++11 起保证一次）。