  
内存对齐是计算机编程中的一个重要概念，特别是在 C 和 C++ 等语言里，它对程序的性能和内存使用有着显著影响。下面将从内存对齐的定义、原因、规则、示例以及优缺点几个方面进行详细讲解。

### 定义
### 内存对齐的基本规则

  

- **成员起始地址**：每个成员的起始地址必须是该成员类型大小的整数倍。例如，`int` 类型（通常 4 字节）的成员，其起始地址必须是 4 的倍数；`double` 类型（通常 8 字节）的成员，其起始地址必须是 8 的倍数。
- **结构体总大小**：结构体的总大小必须是其最大基本数据类型成员大小的整数倍。如果不满足这个条件，编译器会在结构体末尾添加填充字节。

### 示例说明

  


```c
#include <stdio.h>

struct Example1 {
    char c;    // 1 字节
    int i;     // 4 字节
    double d;  // 8 字节
};

struct Example2 {
    double d;  // 8 字节
    char c;    // 1 字节
    int i;     // 4 字节
};

int main() {
    printf("Size of Example1: %zu bytes\n", sizeof(struct Example1));
    printf("Size of Example2: %zu bytes\n", sizeof(struct Example2));
    return 0;
}
```

  

- **`struct Example1`**：
    - `char c` 占 1 字节，起始地址为 0。
    - `int i` 要求 4 字节对齐，由于 `c` 后面只有 1 字节空间，不满足 4 字节对齐要求，所以在 `c` 后面填充 3 字节，`i` 从地址 4 开始，占 4 字节。
    - `double d` 要求 8 字节对齐，此时前面已经有 8 字节，满足对齐要求，`d` 从地址 8 开始，占 8 字节。
    - 结构体总大小为 16 字节，是最大成员 `double` 大小（8 字节）的整数倍。
- **`struct Example2`**：
    - `double d` 占 8 字节，起始地址为 0。
    - `char c` 占 1 字节，从地址 8 开始。
    - `int i` 要求 4 字节对齐，`c` 后面只有 1 字节空间，不满足要求，所以在 `c` 后面填充 3 字节，`i` 从地址 12 开始，占 4 字节。
    - 结构体总大小为 16 字节，是最大成员 `double` 大小（8 字节）的整数倍。
  

内存对齐指的是将数据存储在特定的内存地址上，这些地址是数据类型大小的整数倍。例如，一个 4 字节的 `int` 类型变量通常会被存储在地址为 4 的整数倍的内存位置。编译器会自动插入填充字节，以确保每个变量都满足对齐要求。

### 原因

#### 1. 提高内存访问效率

  

现代计算机的内存系统通常是按照字（word）来进行读写操作的，不同架构的计算机字长不同，如 32 位系统的字长一般是 4 字节，64 位系统的字长一般是 8 字节。如果数据存储的地址是字长的整数倍，那么 CPU 可以在一个内存周期内完成对该数据的读写操作。相反，如果数据没有对齐，CPU 可能需要多个内存周期才能完成读写，从而降低了内存访问效率。

#### 2. 硬件限制

  

某些硬件平台要求数据必须按照特定的对齐方式存储，否则会引发硬件异常或导致程序崩溃。例如，某些 RISC（精简指令集计算机）架构的处理器只支持对齐访问。

### 规则

#### 1. 基本数据类型的对齐值

  

每种基本数据类型都有其默认的对齐值，通常等于该数据类型的大小。例如：

  

- `char`：1 字节
- `short`：2 字节
- `int`：4 字节（在 32 位和大多数 64 位系统中）
- `long long`：8 字节
- `float`：4 字节
- `double`：8 字节

#### 2. 结构体的对齐规则

  

- **成员对齐**：结构体的每个成员都要按照其自身的对齐值进行对齐。即每个成员的起始地址必须是其对齐值的整数倍。如果前一个成员的结束地址不满足下一个成员的对齐要求，编译器会在它们之间插入填充字节。
- **结构体整体对齐**：结构体的总大小必须是其最大成员对齐值的整数倍。如果结构体的实际大小不满足这个要求，编译器会在结构体末尾插入填充字节。

#### 3. 类的对齐规则

  

类的对齐规则与结构体类似，类的成员也要按照其自身的对齐值进行对齐，类的总大小必须是其最大成员对齐值的整数倍。

### 示例

  

收起

cpp

```
#include <iostream>
using namespace std;

// 示例结构体
struct Example {
    char c;     // 1 字节
    int i;      // 4 字节
    short s;    // 2 字节
};

int main() {
    cout << "Size of Example: " << sizeof(Example) << " bytes" << endl;
    return 0;
}
```

#### 分析

  

- `char c`：占用 1 字节，起始地址为 0。
- `int i`：对齐值为 4 字节，由于 `c` 只占用 1 字节，为了满足 `i` 的对齐要求，编译器会在 `c` 后面插入 3 个填充字节，所以 `i` 的起始地址为 4。
- `short s`：对齐值为 2 字节，`i` 占用 4 字节后，`s` 的起始地址为 8，刚好满足对齐要求。
- 结构体整体对齐：最大成员 `int` 的对齐值为 4 字节，结构体实际占用 1 + 3（填充）+ 4 + 2 = 10 字节，为了满足整体对齐要求，编译器会在 `s` 后面插入 2 个填充字节，所以结构体的总大小为 12 字节。

### 优缺点

#### 优点

  

- **提高性能**：通过内存对齐，CPU 可以更高效地访问内存，减少内存访问周期，从而提高程序的执行速度。
- **兼容性**：满足某些硬件平台的对齐要求，保证程序在不同平台上的兼容性。

#### 缺点

  

- **浪费内存**：为了满足对齐要求，编译器会插入填充字节，导致内存空间的浪费。在对内存使用要求较高的场景下，这可能会成为一个问题。

### 手动控制内存对齐

  

在 C++ 中，可以使用 `#pragma pack` 或 `alignas` 关键字来手动控制内存对齐。例如：

  

收起

cpp

```
#include <iostream>
#pragma pack(1)  // 按 1 字节对齐
struct PackedExample {
    char c;
    int i;
    short s;
};
#pragma pack()  // 恢复默认对齐

int main() {
    cout << "Size of PackedExample: " << sizeof(PackedExample) << " bytes" << endl;
    return 0;
}
```

  

在这个示例中，使用 `#pragma pack(1)` 指令将结构体按 1 字节对齐，这样就不会插入填充字节，结构体的总大小为 1 + 4 + 2 = 7 字节。但需要注意的是，手动控制内存对齐可能会降低程序的性能，使用时要谨慎。