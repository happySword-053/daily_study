### 明确的右值引用

当你在非模板上下文中声明 `T&&` 时，`T` 必须是一个具体类型，并且 `T&&` 表示该类型的右值引用。例如：

cpp

深色版本

```
int&& rvalue_ref = 42; // 绑定到右值（临时对象）
```

在这个例子中，`int&&` 是一个明确的右值引用，只能绑定到右值。如果你尝试将它绑定到左值，编译器会报错：

cpp

深色版本

```
int x = 42;
int&& rvalue_ref = x; // 错误：不能将右值引用绑定到左值
```

要使上述代码合法，你需要使用 `std::move` 来显式地将左值转换为右值：

cpp

深色版本

```
int x = 42;
int&& rvalue_ref = std::move(x); // 合法：std::move 将左值转换为右值
```

### 模板中的万能引用

然而，在模板中，`T&&` 可以根据传递给模板的实参被推导为不同的类型，这就是所谓的万能引用或转发引用。例如：

cpp

深色版本

```
template<typename T>
void func(T&& param) {
    // ...
}

int main() {
    int x = 42;

    func(x);              // T 被推导为 int&，因此 T&& 是 int&
    func(std::move(x));   // T 被推导为 int，因此 T&& 是 int&&
    func(42);             // T 被推导为 int，因此 T&& 是 int&&
}
```

在这个例子中，`func` 函数模板中的 `T&& param` 是一个万能引用。根据传递给 `func` 的实参，`T` 可以被推导为不同的类型，使得 `param` 可以灵活地绑定到左值或右值。