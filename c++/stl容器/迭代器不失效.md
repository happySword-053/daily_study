### 哪些容器在什么情况下迭代器不会失效？

了解了迭代器失效的原因，我们就可以根据不同容器的底层实现来判断迭代器失效的规则。

#### 1. `std::list` (链表)

`std::list` 是一个双向链表。它的元素在内存中是不连续存储的，每个节点独立分配内存。

- **不会失效的情况：**
    
    - **任何插入操作**（`insert()`, `push_front()`, `push_back()` 等）都不会使现有迭代器失效，因为新元素只是插入到链表的特定位置，不影响其他节点的内存地址。
        
    - **任何删除操作**（`erase()`, `pop_front()`, `pop_back()` 等），**除了指向被删除元素的迭代器外**，都不会使其他现有迭代器失效。
        
- **会失效的情况：**
    
    - **指向被删除元素的迭代器**会失效。
        

#### 2. `std::map`, `std::set`, `std::multimap`, `std::multiset` (基于红黑树的关联容器)

这些关联容器通常基于**红黑树**实现。每个节点都是独立分配内存的。

- **不会失效的情况：**
    
    - **任何插入操作**都不会使现有迭代器失效，因为新节点的插入只会调整树的平衡，不会改变其他节点的内存地址。
        
    - **任何删除操作**，**除了指向被删除元素的迭代器外**，都不会使其他现有迭代器失效。
        
- **会失效的情况：**
    
    - **指向被删除元素的迭代器**会失效。
        

#### 3. `std::unordered_map`, `std::unordered_set`, `std::unordered_multimap`, `std::unordered_multiset` (基于哈希表的无序关联容器)

这些无序关联容器基于**哈希表**实现。其迭代器失效规则比较复杂。

- **不会失效的情况：**
    
    - **插入操作：** 如果插入元素没有引起**哈希表的重新散列（rehash）**，则所有迭代器都不会失效。
        
    - **删除操作：** **除了指向被删除元素的迭代器外**，其他迭代器通常不会失效。
        
- **会失效的情况：**
    
    - **插入操作导致重新散列 (rehash)：** 当哈希表的负载因子超过阈值，或者在插入时需要分配更大的底层数组时，会发生重新散列。此时，整个哈希表会重建，**所有迭代器都会失效**。
        
    - **指向被删除元素的迭代器**会失效。
        

#### 4. `std::deque` (双端队列)

`std::deque` 通常由一系列固定大小的块组成，通过一个中心映射表管理这些块，以实现两端高效的插入和删除。

- **不会失效的情况：**
    
    - 在两端（`push_front()`, `push_back()`, `pop_front()`, `pop_back()`）插入或删除元素通常**不会使现有迭代器失效**，除非涉及内部块的重新分配或移除。
        
- **会失效的情况：**
    
    - **在队列中间插入或删除元素：** 这会导致其后的所有迭代器失效。
        
    - **任何操作导致内存重新分配（如扩容导致新的块分配和现有块的移动）：** 尽管 `deque` 尽量避免大规模数据移动，但在某些情况下，尤其是在容量接近极限时，可能会导致迭代器失效。C++ 标准规定，**除两端操作外的插入/删除，以及容量变化引起的重新分配，都会使所有迭代器失效。** 简单来说，**中间插入/删除会导致失效。**
        

#### 5. `std::vector` (动态数组)

`std::vector` 是一个动态数组，其元素在内存中是**连续存储**的。

- **不会失效的情况：**
    
    - **在末尾插入元素 (`push_back()`) 且未引起内存重新分配 (reallocation) 时，**指向现有元素的迭代器不会失效，但 `end()` 迭代器可能会失效（因为指向了新的尾部之后的位置）。
        
- **会失效的情况（非常频繁）：**
    
    - **任何插入操作（包括 `push_back()`）引起了内存重新分配：** 这会导致**所有迭代器**失效。
        
    - **在 `begin()` 之后插入元素：** 这会使插入点及之后的所有迭代器失效。
        
    - **在 `begin()` 之后删除元素（包括 `erase()`）：** 这会使删除点及之后的所有迭代器失效。
        
    - **`clear()` 操作：** 会使所有迭代器失效。
        
    - `resize()` `reserve()` 这些操作如果导致重新分配，也会使所有迭代器失效。
        

---



|容器类型|插入操作导致迭代器失效？|删除操作导致迭代器失效？|特殊说明|
|---|---|---|---|
|`std::vector`|**可能** (若引起重新分配，则全部失效)|**可能** (删除点及之后全部失效)|连续存储，容量变化或中间修改风险高。|
|`std::list`|**否**|**仅被删除元素的迭代器失效**|链表结构，不涉及大规模内存移动。|
|`std::deque`|**可能** (中间插入，或两端插入引起内存分配)|**可能** (中间删除，或两端删除引起块移除)|尽管设计上优化两端操作，但中间操作和底层块管理仍有失效风险。|
|`std::map`/`set`等|**否**|**仅被删除元素的迭代器失效**|基于红黑树，节点独立分配，结构调整不影响其他节点地址。|
|`std::unordered_map`/`set`等|**可能** (若引起 `rehash`，则全部失效)|**仅被删除元素的迭代器失效** (不涉及 `rehash` 的情况下)|基于哈希表，`rehash` 会导致所有元素重新散列，从而使所有迭代器失效。这是与树形容器最大的区别。|

