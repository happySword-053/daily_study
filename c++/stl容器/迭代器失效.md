### 迭代器失效的普遍原因

迭代器失效通常发生在容器的底层存储结构发生变化时。这些变化包括：

- **内存重新分配 (Reallocation)：** 当容器内部的数组需要扩容或缩容时，它可能会分配一块新的内存区域，并将所有元素复制到新位置，然后释放旧内存。此时，指向旧内存的迭代器就会失效。
    
- **元素插入/删除：** 元素的插入或删除可能会改变现有元素在内存中的位置，或者使得迭代器指向一个已被删除的元素。
    
### 导致迭代器失效的常见操作

以下是导致不同 STL 容器迭代器失效的常见操作：

#### 1. `std::vector` (动态数组)

`std::vector` 的底层是连续内存。因此，任何可能导致内存重新分配或元素位置改变的操作，都会导致迭代器失效。

- **内存重新分配 (Reallocation)：**
    
    - **插入操作（`push_back()`, `insert()`）导致容量不足：** 当 `vector` 需要存储更多元素但当前容量不足时，它会分配一块更大的新内存，将所有现有元素复制到新位置，然后释放旧内存。此时，**所有迭代器**（包括 `end()` 迭代器，即使它现在指向的是新内存中的末尾）都会失效。
        
    - **`reserve()` 增加容量：** 如果 `reserve()` 请求的容量大于当前容量，也会引起重新分配，导致**所有迭代器**失效。
        
    - **`shrink_to_fit()` 缩减容量：** 如果 `shrink_to_fit()` 成功缩减了容量，也会引起重新分配，导致**所有迭代器**失效。
        
- **元素插入：**
    
    - **`insert()` 到非末尾位置：** 在 `begin()` 和 `end()` 之间的任何位置插入元素，都会导致插入点及之后的所有元素后移，从而使**插入点及之后的所有迭代器**失效。
        
    - **`push_back()` 导致重新分配：** 如上所述，会使所有迭代器失效。
        
- **元素删除：**
    
    - **`erase()` 删除元素：** 删除一个元素会导致其后的所有元素前移，从而使**被删除元素的迭代器以及其后所有迭代器**失效。
        
    - **`pop_back()` 删除末尾元素：** `pop_back()` 不会使除 `end()` 以外的任何迭代器失效（`end()` 迭代器通常会失效，因为它现在指向新的尾部之后）。
        
    - **`clear()` 清空容器：** 会使**所有迭代器**失效。
        

#### 2. `std::deque` (双端队列)

`std::deque` 的元素通常存储在多个不连续的块中。

- **在队列中间插入或删除元素：**
    
    - `insert()` 和 `erase()` 在 `begin()` 和 `end()` 之间的位置操作时，会使**操作点及之后的所有迭代器**失效。
        
- **任何导致底层块重新分配或移除的操作：**
    
    - 尽管 `deque` 设计上尽量避免，但在某些极端情况下（例如，某些实现中当容量接近极限时在两端插入），仍可能导致部分或**所有迭代器失效**。C++ 标准相对宽松，但通常认为**非两端的操作**和**容量变化**可能会导致迭代器失效。
        

#### 3. `std::list` (双向链表)

`std::list` 的元素独立存储，通过指针连接。

- **删除操作：**
    
    - **只有指向被删除元素的迭代器会失效。** 其他所有迭代器在删除操作后仍然有效。
        
- **插入操作：**
    
    - 任何插入操作都不会使现有迭代器失效。
        

#### 4. `std::map`, `std::set`, `std::multimap`, `std::multiset` (基于红黑树的关联容器)

这些容器通常基于平衡二叉搜索树（如红黑树）实现，节点也是独立分配的。

- **删除操作：**
    
    - **只有指向被删除元素的迭代器会失效。** 其他所有迭代器在删除操作后仍然有效。
        
- **插入操作：**
    
    - 任何插入操作都不会使现有迭代器失效。
        

#### 5. `std::unordered_map`, `std::unordered_set`, `std::unordered_multimap`, `std::unordered_multiset` (基于哈希表的无序关联容器)

这些容器基于哈希表实现，依赖于散列函数和桶的概念。

- **重新散列 (Rehash)：**
    
    - **当插入元素导致哈希表需要扩容并重新散列时**（例如，负载因子超过阈值，或 `reserve()` 操作），哈希表中所有元素都会被重新计算哈希值并放入新的桶中。此时，**所有迭代器都会失效**。
        
- **删除操作：**
    
    - **只有指向被删除元素的迭代器会失效。** 如果删除操作没有导致重新散列，其他迭代器通常保持有效。
        

---

### 总结表格（导致迭代器失效的情况）

| 容器类型                        | 插入操作导致失效?                      | 删除操作导致失效?                  | 其他可能导致失效的操作                              |
| --------------------------- | ------------------------------ | -------------------------- | ---------------------------------------- |
| `std::vector`               | **是** (若引起重新分配，或非末尾插入)         | **是** (删除点及之后，或 `clear()`) | `reserve()`, `shrink_to_fit()` (若引起重新分配) |
| `std::list`                 | **否**                          | **是** (仅被删除元素的迭代器)         | 无                                        |
| `std::deque`                | **是** (中间插入，或在某些实现中两端插入引起重新分配) | **是** (中间删除)               | 无                                        |
| `std::map`/`set`等           | **否**                          | **是** (仅被删除元素的迭代器)         | 无                                        |
| `std::unordered_map`/`set`等 | **是** (若引起 `rehash`)           | **是** (仅被删除元素的迭代器)         | `rehash()`, `reserve()` (若引起重新散列)        |
