在 C/C++ 中，**内存泄漏**（Memory Leak）和**悬垂指针**（Dangling Pointer）都是因不当管理动态内存（heap）而产生的常见 bug。下面从概念、产生原因、危害、检测与避免等方面做详细讲解。

---

## 一、内存泄漏（Memory Leak）

### 1. 概念

当程序在堆上申请了一块内存（`new`、`malloc` 等），却始终没有相应地释放（`delete`、`free` 等），导致这块内存既无法被程序再利用，也无法被操作系统回收，就称为内存泄漏。

### 2. 典型场景



`void leak_example() {     int* p = new int[100];  // 申请 100 个 int     // ……中间可能很多逻辑     // 忘记 delete[] p; }  // 函数结束，p 变量销毁，但堆内存依旧占用`

#### 常见原因

1. **早返回**：在多分支或异常路径中，`delete` 没写或漏写。
    
2. **循环／缓存类**：容器不停地 `push_back` 新指针，却没在适当时机 `delete` 旧数据。
    
3. **智能指针误用**：循环引用（`shared_ptr` A 引用 B，B 又引用 A），导致引用计数永远不为 0。
    

### 3. 危害

- 长时间运行的程序（服务器、守护进程）会耗尽可用内存，最终导致崩溃或被操作系统 OOM 杀死。
    
- 难以复现、定位，随着功能增多，泄漏严重性会累积放大。
    

### 4. 检测工具与手段

- **Valgrind/Memcheck**：Linux 下经典工具，能报告未释放内存的大小与分配栈。
    
- **AddressSanitizer (ASan)**：编译时开关（`-fsanitize=address`），快速定位泄漏和越界。
    
- **Visual Studio CRT Leak Detection**：在 Windows 下可用 `_CrtDumpMemoryLeaks()` 等。
    

### 5. 避免策略

1. **RAII + 智能指针**
    
    - `std::unique_ptr<T>`：独占所有权，超出作用域自动释放；
        
    - `std::shared_ptr<T>`：共享所有权，自动计数释放（注意循环引用）。
        
2. **容器存值**：尽量存放对象而非裸指针。
    
3. **统一接口**：所有 `new` 与 `delete` 在同一抽象层面管理（如工厂、管理器类）。
    
4. **异常安全**：采用“先分配、后添加”或“析构中释放”模式，保证异常路径也能释放。
    

---

## 二、悬垂指针（Dangling Pointer）

### 1. 概念

指针指向的内存已被释放或超出了其作用域，但指针本身仍持有那块旧地址。后续若再通过该指针读/写，就会产生未定义行为。

### 2. 典型场景



`int* make_ptr() {     int local = 42;     return &local;  // 返回指向栈上变量的指针 —— 悬垂指针！ }  void use_ptr() {     int* p = make_ptr();     // 此时 p 指向的内存已被释放（函数栈帧弹出），访问 *p 就是未定义行为     std::cout << *p << "\n";   }`

或动态释放后仍使用：



`int* p = new int(10); delete p; *p = 20;  // 悬垂指针访问`

### 3. 危害

- **崩溃**：访问非法内存会触发段错误（segfault）。
    
- **数据破坏**：可能不报错，但你会读到垃圾或者覆盖他人内存，导致难以追踪的逻辑错误。
    

### 4. 检测与防范

- **初始化为 `nullptr`**：任何指针若不立即赋合法地址，就置为 `nullptr`，并在释放后也设为 `nullptr`。
    
- **避免裸指针**：尽量使用智能指针、引用或容器管理对象生命周期。
    
- **范围绑定**（Scoped Resource）：例如 `std::vector`、`std::string` 等封装类型，不手动管理内存。
    
- **工具检测**：ASan、Valgrind 同样能报告对已释放内存的访问。
    

### 5. 示例改进



```c++
`std::unique_ptr<int> make_uptr() {     auto p = std::make_unique<int>(42);     return p;  // 迁移所有权，无悬垂风险 }  void use_uptr() {     auto p = make_uptr();     // 使用 p，超出作用域自动 delete，无悬垂     std::cout << *p << "\n"; }`
```

---

### 三、总结对比

|特性|内存泄漏（Leak）|悬垂指针（Dangling）|
|---|---|---|
|根本原因|申请了却忘了释放|释放了却还在使用|
|表现|程序运行中可用内存持续减少|读取/写入已释放内存，未定义行为|
|检测|Valgrind/Memcheck、ASan Leak Check|ASan、Valgrind invalid read/write|
|防范|RAII、智能指针、容器存值|释放后置 `nullptr`、智能指针与引用管理生命周期|