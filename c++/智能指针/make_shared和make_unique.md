**`std::make_shared` 和直接使用 `new` 创建 `std::shared_ptr` 有什么区别？**

虽然两者最终都能得到一个管理相同对象的 `shared_ptr`，但它们的底层实现和效率却大不相同。**`std::make_shared` 是更推荐的创建方式。**

---

### 1. 直接创建 `std::shared_ptr` (使用 `new`)

C++

```
std::shared_ptr<MyObject> ptr = std::shared_ptr<MyObject>(new MyObject());
```

这种方式可以理解为两个独立的操作：

1. **第一次内存分配：** `new MyObject()` 会在堆上为 `MyObject` **对象本身**分配内存。
    
2. **第二次内存分配：** `std::shared_ptr<MyObject>(...)` 的构造函数会为 `shared_ptr` 所需的**控制块 (Control Block)** 分配内存。这个控制块包含了引用计数、删除器等管理信息。
    

**内存布局（概念上）：**

```
     堆内存区域 A                    堆内存区域 B
   +-------------------+           +-------------------+
   |  MyObject 对象    |           |  Control Block    |
   | (实际数据)        |           |  - strong_count   |
   +-------------------+           |  - weak_count     |
        ^                          |  - deleter        |
        |                          |  - allocator      |
        |                          +-------------------+
        |                                ^
        |                                |
   std::shared_ptr<MyObject> ptr          |
      - ptr_to_object --------------------
      - ptr_to_control_block --------------
```

**缺点：**

- **两次内存分配：** 导致两次系统调用开销，降低性能。
    
- **缓存不友好：** 对象和控制块位于内存中不同的位置，可能降低缓存命中率。
    
- **异常安全隐患：** 在极少数情况下，如果 `new MyObject()` 成功，但在 `shared_ptr` 构造函数初始化**之前**（例如，在调用另一个函数准备 `shared_ptr` 参数时）发生异常，`MyObject` 分配的内存可能无法被正确释放，导致内存泄漏。虽然现代编译器和标准库实现已尽量避免，但这仍是理论上的风险。
    

---

### 2. 使用 `std::make_shared` (推荐)

C++

```
std::shared_ptr<MyObject> ptr = std::make_shared<MyObject>();
```

`std::make_shared` 是一个工厂函数，它只进行**一次内存分配**：

1. **一次内存分配：** `make_shared` 会在堆上分配一块足够大的连续内存，**同时容纳 `MyObject` 对象本身和其对应的控制块**。
    

**内存布局（概念上）：**

```
     堆内存区域 (一块连续内存)
   +-------------------+
   |  Control Block    |
   |  - strong_count   |
   |  - weak_count     |
   |  - deleter        |
   |  - allocator      |
   |-------------------|
   |  MyObject 对象    |  (实际数据，紧随控制块之后)
   +-------------------+
        ^
        |
   std::shared_ptr<MyObject> ptr
      - ptr_to_object -------------------
      - ptr_to_control_block -------------
```

**优点：**

- **效率更高：** 只进行**一次内存分配**，减少了系统调用开销，提高了性能。
    
- **缓存友好：** 对象和控制块存储在连续的内存区域中，更有利于 CPU 缓存，提高访问速度。
    
- **异常安全：** 整个分配和初始化过程是原子性的，从根本上避免了上述直接创建可能存在的异常安全问题。
    
- **代码简洁：** 语法更简洁明了。


make_unique同理
然而，由于 `shared_ptr` 和 `unique_ptr` 管理所有权的方式不同，它们内部的实现细节和主要优势点也略有差异。

---

### `std::make_shared` 的原理与优势

如我们之前讨论的：

- **所有权语义：** 共享所有权 (`shared_ptr`)。
    
- **内存分配：** `std::make_shared<T>(args...)` 会进行**一次内存分配**，同时为 `T` 对象本身和 `shared_ptr` 所需的**控制块**（包含强/弱引用计数等）分配一块连续的内存。
    
- **核心优势：**
    
    1. **效率：** 减少了一次内存分配的系统调用开销。
        
    2. **缓存：** 对象和控制块在内存中是连续的，更缓存友好。
        
    3. **异常安全：** 避免了 `shared_ptr<T>(new T())` 可能在 `new` 和 `shared_ptr` 构造之间发生的内存泄漏风险。
        

---

### `std::make_unique` 的原理与优势

`std::make_unique` 是 C++14 引入的，用来创建 `std::unique_ptr`。

- **所有权语义：** 独占所有权 (`unique_ptr`)。
    
- **内存分配：** `std::make_unique<T>(args...)` 仅仅进行**一次内存分配**，即为 `T` 对象本身分配内存。
    
    - `unique_ptr` 不需要额外的控制块（因为它没有引用计数、没有 `weak_ptr` 的概念，也不支持共享所有权）。
        
    - 所以，它分配的内存就是纯粹的对象所需的内存。
        
- **核心优势：**
    
    1. **效率：** 减少了一次内存分配的系统调用开销（相比于 `unique_ptr<T> p(new T());`）。虽然 `unique_ptr` 不像 `shared_ptr` 那样有控制块的额外内存开销，但 `new T()` 本身就是一个独立的分配。`make_unique` 将分配和构造打包，更高效。
        
    2. **异常安全：** 与 `make_shared` 类似，它避免了 `unique_ptr<T> p(new T())` 在表达式求值顺序不确定时可能导致的内存泄漏问题。
        
    3. **代码简洁：** `make_unique<T>()` 比 `unique_ptr<T>(new T())` 更短更易读。
        

---

### 相同点与不同点总结

---

| 特性         | `std::make_shared`              | `std::make_unique`                                |
| ---------- | ------------------------------- | ------------------------------------------------- |
| **目标智能指针** | `std::shared_ptr` (共享所有权)       | `std::unique_ptr` (独占所有权)                         |
| **分配次数**   | **一次** (对象 + 控制块)               | **一次** (仅对象)                                      |
| **主要优势**   | **效率更高、缓存友好、异常安全**              | **效率更高、异常安全、代码简洁**                                |
| **底层需求**   | 需要为对象和引用计数器/控制块分配内存             | 只需要为对象本身分配内存 (无控制块)                               |
| **为何存在**   | 优化 `shared_ptr` 的构造，避免两次分配和异常隐患 | 优化 `unique_ptr` 构造，提供与 `make_shared` 对称的接口，避免异常隐患 |