在哈希表（Hash Table）中，不可避免地会出现**哈希冲突**（多个键映射到同一槽位）的情况。常见的解决冲突的方法主要分为两大类：**开放寻址（Open Addressing）**和**分离链接（Separate Chaining）**，除此之外还有一些更先进的策略。下面逐一介绍。

---

## 一、分离链接法（Separate Chaining）

- **原理**：每个哈希槽（bucket）维护一个链表（或其他容器，如平衡树、跳表等），所有冲突映射到同一槽的元素都插入到这个链表中。
    
- **实现示例**（伪码）：
    
    cpp
    
    复制编辑
    
    `struct Node {     Key   key;     Value val;     Node* next; }; std::vector<Node*> table; // 大小为 N  void insert(Key k, Value v) {     size_t idx = hash(k) % N;     auto head = table[idx];     // 可以选择头插或尾插     Node* node = new Node{k, v, head};     table[idx] = node; }`
    
- **优缺点**：
    
    - 优点：删除操作简单；对负载因子（α = 元素数/N）容忍度高，性能下降平滑；
        
    - 缺点：需要额外的指针空间；当冲突严重时，链表退化成 O(n) 查找。
        

---

## 二、开放寻址法（Open Addressing）

将冲突元素放到“表内”其他空闲槽中。常见策略有：

### 1. 线性探测（Linear Probing）

- **探测序列**：  
    h,(h+1)  N,(h+2)  N,…h, (h+1)\bmod N, (h+2)\bmod N, \dotsh,(h+1)modN,(h+2)modN,…
    
- **优缺点**：
    
    - 优点：实现简单，缓存友好；
        
    - 缺点：容易产生“主簇效应”（primary clustering），导致探测长度增加。
        

### 2. 二次探测（Quadratic Probing）

- **探测序列**：  
    h, (h+12)  N, (h+22)  N, (h+32)  N,…h,\ (h + 1^2)\bmod N,\ (h + 2^2)\bmod N,\ (h + 3^2)\bmod N,\dotsh, (h+12)modN, (h+22)modN, (h+32)modN,…
    
- **优缺点**：
    
    - 优点：减轻主簇效应；
        
    - 缺点：需保证 `N` 为质数或满足特定条件，才能覆盖到所有槽；删除较复杂（需标记已删除）。
        

### 3. 双重哈希（Double Hashing）

- **探测序列**：  
    h1, (h1+h2)  N, (h1+2h2)  N, …h_1,\ (h_1 + h_2) \bmod N,\ (h_1 + 2h_2)\bmod N,\ \dotsh1​, (h1​+h2​)modN, (h1​+2h2​)modN, …  
    其中 `h₂(k)` 必须与 `N` 互质。
    
- **优缺点**：
    
    - 优点：最少的聚集效应；
        
    - 缺点：需要两个高质量哈希函数，计算开销较大。
        

---

## 三、再哈希（Rehashing）

当负载因子 α 超过某个阈值（如 0.7）时，**动态扩容**为新的、更大的表，并将所有元素重新插入。对分离链接和开放寻址都适用，能保持平均 O(1) 性能。

cpp

复制编辑

`if (size() > load_factor * N) {     resize(N * 2);     // 重新哈希所有元素 }`