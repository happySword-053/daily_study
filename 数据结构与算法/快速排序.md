#### 1. 快速排序（Quick Sort）

- **原理**：分治法
    
    1. 选择基准（pivot）
        
    2. 分区：小于基准的放左边，大于的放右边
        
    3. 递归排序左右分区
        
- **特点**：
    
    - 平均时间复杂度：O(n log n)
        
    - 最坏时间复杂度：O(n²)（当分区不平衡时）
        
    - 空间复杂度：O(log n)（递归栈）
        
    - 不稳定排序
        
- **优化**：
    
    - 三数取中法选基准
        
    - 小数组切换为插入排序
        
    - 尾递归优化
        
- **C++实现（Lomuto分区）**：
    


```c++

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            swap(arr[i], arr[j]);
            i++;
        }
    }
    swap(arr[i], arr[high]);
    return i;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi-1);
        quickSort(arr, pi+1, high);
    }
}
```
优化
```c++
void quickSort(int arr[], int low, int high) {
    while (low < high) {
        // 随机选pivot并与low位置交换
        int pivotIdx = low + std::rand() % (high - low + 1);
        std::swap(arr[low], arr[pivotIdx]);

        int pivot = arr[low];
        int left  = low + 1;
        int right = high;

        while (left <= right) {
            while (left <= right && arr[left]  <= pivot) left++;
            while (left <= right && arr[right] >= pivot) right--;
            if (left < right) {
                std::swap(arr[left], arr[right]);
            }
        }
        std::swap(arr[low], arr[right]);

        // 先递归处理较小的区间，尾递归消除另一个
        if (right - 1 - low < high - (right + 1)) {
            quickSort(arr, low, right - 1);
            low = right + 1;  // 变成尾递归
        } else {
            quickSort(arr, right + 1, high);
            high = right - 1; // 变成尾递归
        }
    }
}

```
- **每一次 `partition`**，无论是递归调用还是循环推进，都要对当前区间做一次线性扫描，时间是 O(k)（k = 子区间长度）。
    
- **不管是递归还是循环**，最终都会对整个数组的所有元素进行划分：第 1 轮划分花 O(N)，第 2 轮花 O(N₁) + O(N₂)…，构成一颗递归树。
    
- “先小后大＋尾递”**只是把对大区间的那条“枝”改成了 `while` 循环**，并没有省掉任何一次 `partition` 或比较操作。
    
- 因此，**时间复杂度**依然是：
    
    - **最坏情况**（每次都划得极端不平衡）O(N²)，
        
    - **期望／平均情况**（随机 pivot 导致划分较平衡）O(N log N)。
        

---

### 2. 提到的“排序数组＋总是选到极端 pivot”场景

- 确实，如果输入已经完全有序，且**极端不幸**地**每一次**都随机选到了最左或最右的元素作为 pivot，那么划分序列长度会是 N−1, N−2, …, 1，比较次数 ∑_{k=1}^N k = O(N²)。
    
- **但随机化的意义就在于**：出现“每次都选极端”的概率只有
    
    2N×2N−1×⋯×21  =  2NN!  ≈  非常非常小 \frac{2}{N} \times \frac{2}{N-1} \times \cdots \times \frac{2}{1} \;=\; \frac{2^N}{N!} \;\approx\; \text{非常非常小}N2​×N−12​×⋯×12​=N!2N​≈非常非常小
    
    因此，**平均下来**你会得到 O(N log N) 的性能保证，而不是 O(N²)。
    

---



- **尾递归消除**：限制了最坏的**空间**（栈）复杂度为 O(log N)，但**不影响**每次都要做的划分工作，所以**不改变**时间复杂度。
    
- **随机化 pivot**：把“最坏划分”变成了“极低概率事件”，平均时间复杂度稳定在 O(N log N)。
    
- 两者结合，能让快速排序 **既快**（期望 O(N log N)）又**稳**（最坏栈深 O(log N)）。