在C++中，拷贝构造函数必须声明为引用类型，主要原因在于**避免无限递归调用**。以下是详细解释：

---

### 核心原因：防止无限递归

1. **按值传递的陷阱**  
    如果拷贝构造函数的参数是**按值传递**（而非引用），那么当调用拷贝构造函数时，需要将实参复制给形参。但复制实参的过程本身就需要调用拷贝构造函数，这会导致**无限递归调用**，最终导致栈溢出（Stack Overflow）。
    
    cpp
    
    复制
    
    class A {
    public:
        A() {}
        A(A a) { /* 错误：参数是值传递 */ } // 无限递归！
    };
    
    A obj1;
    A obj2(obj1); // 调用A(A a)，需要复制obj1到形参a，触发递归拷贝
    
2. **引用传递的解决方案**  
    将参数声明为引用（如`const A&`）可以避免复制实参。引用只是对象的别名，传递时无需调用拷贝构造函数，从而打破递归链。
    
    cpp
    
    复制
    
    class A {
    public:
        A() {}
        A(const A& other) { /* 正确：参数是引用 */ }
    };
    

---

### 其他原因

1. **效率优化**  
    引用传递避免了不必要的对象复制，提升了性能（尤其对大型对象）。
    
2. **语法强制约束**  
    C++标准明确规定，拷贝构造函数的参数必须是引用类型。如果声明为值传递，编译器会报错。
    

---

### 总结

|参数类型|行为|结果|
|---|---|---|
|值传递|触发递归拷贝|栈溢出（编译错误）|
|引用传递|直接传递对象别名|正常初始化|

因此，拷贝构造函数必须声明为引用类型，这是C++语法和语义的共同要求。