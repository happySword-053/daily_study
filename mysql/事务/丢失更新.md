**丢失更新（Lost Update**是一种并发事务问题，指两个事务同时读取并修改同一条数据时，后一个事务的更新覆盖了前一个事务的更新，导致前一个事务的修改丢失。丢失更新会破坏数据一致性，因此需要通过适当的机制来避免。

---

### **丢失更新的场景**

#### **情景描述**

假设有一个表 `accounts` 记录账户余额：

sql

复制代码

`CREATE TABLE accounts (     id INT PRIMARY KEY,     balance DECIMAL(10, 2) ); INSERT INTO accounts (id, balance) VALUES (1, 100.00);`

两个用户（事务 A 和事务 B）同时读取并更新同一个账户余额。

#### **步骤：丢失更新**

1. **事务 A** 读取账户余额：
    
    sql
    
    复制代码
    
    `START TRANSACTION; SELECT balance FROM accounts WHERE id = 1; -- 查询结果：balance = 100.00`
    
2. **事务 B** 也读取账户余额：
    
    sql
    
    复制代码
    
    `START TRANSACTION; SELECT balance FROM accounts WHERE id = 1; -- 查询结果：balance = 100.00`
    
3. **事务 A** 将余额增加 50 并更新：
    
    sql
    
    复制代码
    
    `UPDATE accounts SET balance = 150.00 WHERE id = 1; COMMIT;`
    
4. **事务 B** 将余额减少 30 并更新：
    
    sql
    
    复制代码
    
    `UPDATE accounts SET balance = 70.00 WHERE id = 1; COMMIT;`
    

最终结果：

- 账户余额变为 **70.00**（事务 B 的更新覆盖了事务 A 的更新）。
- **事务 A 的修改丢失了**。

---

### **丢失更新的分类**

#### **1. 显式丢失更新**

事务 A 和事务 B 都执行了更新操作，后提交的事务覆盖了先提交的事务。上面的例子就是显式丢失更新的情况。

#### **2. 隐式丢失更新**

事务 B 提交时，其更新实际上是基于过时的数据，但事务 A 的更新并没有显式被覆盖，而是被忽略。这通常发生在业务逻辑依赖查询结果进行计算时。

---

### **避免丢失更新的解决方案**

丢失更新是典型的并发事务问题，需要通过以下方式避免：

#### **1. 使用事务隔离级别**

##### **READ COMMITTED**

- 在该隔离级别下，每次读取数据时都会获取最新已提交的值，避免事务读取未提交数据导致的数据覆盖。
- **问题**：仍然可能发生丢失更新，因为每个事务基于读取时的数据执行更新，最终的更新仍可能覆盖。

##### **REPEATABLE READ**

- 确保事务在运行期间始终读取到一致性快照，不会被其他事务的更新影响。
- **问题**：虽然解决了不可重复读问题，但如果事务间没有加锁，仍可能出现丢失更新。

##### **SERIALIZABLE**

- 最严格的隔离级别，事务执行范围加锁，完全避免丢失更新，因为其他事务无法并发修改相同的数据。

---

#### **2. 显式加锁**

通过在查询中显式加锁，确保事务间的独占性访问：

##### **SELECT ... FOR UPDATE**

对查询的行加排他锁，防止其他事务对相同数据进行修改。例如：

1. **事务 A** 加锁读取：
    
    sql
    
    复制代码
    
    `START TRANSACTION; SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- 加排他锁，阻止其他事务对该行的修改。`
    
2. **事务 B** 尝试修改：
    
    sql
    
    复制代码
    
    `START TRANSACTION; UPDATE accounts SET balance = 70.00 WHERE id = 1; -- 阻塞，直到事务 A 提交。`
    
3. **事务 A** 修改并提交后，事务 B 才能继续。
    

**效果**：加锁机制确保只有一个事务能修改同一行数据，从而避免丢失更新。

---

#### **3. 乐观锁（版本控制）**

乐观锁通过版本号或时间戳检测数据是否被其他事务修改，从而避免覆盖更新：

##### **示例：使用版本号**

1. 在表中添加一个版本号字段 `version`：
    
    sql
    
    复制代码
    
    `ALTER TABLE accounts ADD version INT DEFAULT 1;`
    
2. **事务 A** 查询并更新时携带版本号：
    
    sql
    
    复制代码
    
    `SELECT balance, version FROM accounts WHERE id = 1; -- 查询结果：balance = 100.00, version = 1  UPDATE accounts SET balance = 150.00, version = version + 1 WHERE id = 1 AND version = 1; -- 检查 version 是否匹配，只有匹配时才更新。`
    
3. **事务 B** 也查询同一条记录，尝试更新时版本号不匹配：
    
    sql
    
    复制代码
    
    `UPDATE accounts SET balance = 70.00, version = version + 1 WHERE id = 1 AND version = 1; -- 更新失败，因为 version 已被事务 A 修改为 2。`
    

**效果**：乐观锁通过版本号检测冲突，避免丢失更新。

---

#### **4. 应用层解决方案**

应用层可以通过控制事务的操作顺序，确保数据更新的正确性：

- **读-改-写模型**：明确在读取数据后进行修改前验证数据是否已被修改。
- **重试机制**：在检测到冲突后重新读取数据并重试事务操作。

---

### **总结**

|**解决方案**|**优点**|**适用场景**|
|---|---|---|
|提高事务隔离级别|自动避免问题，无需显式加锁|数据一致性要求高但性能需求适中的场景。|
|显式加锁（FOR UPDATE）|明确控制并发，防止其他事务修改数据|确定只允许一个事务修改某条数据时。|
|乐观锁（版本控制）|非阻塞，适合高并发场景|高并发且丢失更新风险较大的场景。|
|应用层控制|灵活实现，减少数据库负担|需要根据业务逻辑定制的场景，例如对关键业务字段的精确控制。|

丢失更新是并发控制中一个重要的问题，针对不同场景选择合适的解决方案可以有效避免数据不一致和覆盖的问题。