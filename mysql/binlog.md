Binlog（二进制日志）是 MySQL 中非常重要的一个特性，下面将从基本概念、作用、格式、写入机制、使用场景等方面详细介绍。

### 基本概念

  

Binlog 是 MySQL 的一种二进制日志文件，以二进制的形式记录了对 MySQL 数据库执行更改的所有操作，不包括查询操作（如 `SELECT`）。这些操作包括 `INSERT`、`UPDATE`、`DELETE` 等，它是一种逻辑日志，记录的是 SQL 语句的逻辑操作。

### 作用

  

- **数据恢复**：当数据库发生故障或数据丢失时，可以通过回放 Binlog 中的操作来恢复数据到指定的时间点，实现增量恢复。
- **主从复制**：在主从复制架构中，主服务器将 Binlog 发送给从服务器，从服务器解析并执行这些日志中的操作，从而实现主从数据的同步。
- **审计**：可以通过分析 Binlog 来了解数据库的变更历史，进行审计和合规性检查。

### 格式

  

MySQL 支持三种不同的 Binlog 格式，每种格式有不同的特点和适用场景。

  

`binlog` 主要有三种事件存储格式，可以通过 `binlog_format` 参数进行配置：

1. **Statement-Based Logging (SBR)**：**基于语句的日志**
    
    - **记录内容：** 记录的是执行的**SQL 语句本身**。例如，如果你执行 `UPDATE users SET age = age + 1 WHERE id = 1;`，`binlog` 就会记录这条 `UPDATE` 语句。
    - **优点：**
        - **日志文件小：** 只需要记录 SQL 语句，日志量相对较小。
        - **恢复/复制时效率高：** 在某些情况下，一条 SQL 语句可能影响大量行，但日志只记录一条语句，效率较高。
    - **缺点：**
        - **可能导致主从不一致：** 这是 SBR 最大的问题。
            - **不确定函数：** 包含不确定性函数（如 `NOW()`, `UUID()`, `RAND()`）的语句。主库和从库执行同一条 SQL 语句时，由于时间点、随机数种子等不同，可能产生不同的结果。
            - **自增 ID：** `INSERT ... ON DUPLICATE KEY UPDATE` 或批处理插入时，自增 ID 的生成顺序可能在主从库上不同。
            - **无主键的 `UPDATE`/`DELETE`：** 如果 `UPDATE`/`DELETE` 语句没有使用主键或唯一索引，且 `WHERE` 子句匹配了多行，在主从库上由于行扫描顺序可能不同，导致更新/删除的不是同一批行。
        - **锁竞争：** 如果一条 SQL 语句在从库执行时需要加锁，那么从库上可能会有锁竞争，影响从库的读性能。
2. **Row-Based Logging (RBR)**：**基于行的日志**
    
    - **记录内容：** 不记录 SQL 语句，而是记录每一行数据的**实际变更**。例如，如果 `UPDATE` 将一行数据的 `age` 从 20 改为 21，`binlog` 会记录该行数据的**旧值**和**新值**。
    - **优点：**
        - **数据一致性高：** 彻底避免了 SBR 格式可能导致的主从不一致问题，因为它记录的是最终的数据变化，无论 SQL 语句如何复杂或包含不确定性函数。
        - **更适合数据审计：** 可以精确地知道哪些行被修改了，以及修改前后的值。
    - **缺点：**
        - **日志文件大：** 每一行数据的每次变更都会被记录，即使一条 `UPDATE` 语句影响了百万行，也会产生百万条行变更记录，导致日志量急剧增加。
        - **可读性差：** `binlog` 内容是二进制的，需要 `mysqlbinlog` 工具才能解析，且解析出来的是行变更事件，不如 SQL 语句直观。
3. **Mixed Logging (MBR)**：**混合日志格式** (推荐，也是 MySQL 5.7+ 的默认值)
    
    - **记录内容：** 结合了 SBR 和 RBR 的优点。
    - **原理：** 默认情况下使用 **Statement-Based Logging (SBR)**。当遇到一些不确定性操作（如包含 `NOW()` 函数、特定触发器、存储过程等）时，MySQL 会自动切换到 **Row-Based Logging (RBR)** 来记录这些操作，以确保主从一致性。
    - **优点：**
        - **兼顾一致性和效率：** 尽可能地保持日志文件较小，同时在必要时保证主从数据一致性。
        - **易于维护：** 大多数情况下，你不需要关心它何时切换格式，MySQL 会自动处理。
    - **缺点：**
        - **逻辑复杂性增加：** 需要了解 MySQL 内部的切换规则。
        - **仍然可能产生大日志：** 在发生切换到 RBR 的场景时。 
mysql中有score记录成绩，执行 `update score set math = math + 1;`

ROW格式下，执行`mysqlbinlog -v binlog.00002`，得到如下内容

![[Pasted image 20250217112434.png]]

STATEMENT格式下，执行`mysqlbinlog binlog.00003`，得到如下内容

![[Pasted image 20250217112443.png]]
### 写入机制

  

- **事务提交时写入**：当一个事务提交时，MySQL 会将该事务中的所有操作记录到 Binlog 中。在写入 Binlog 之前，会先将日志内容写入到 Binlog 缓存中。
- **刷新到磁盘**：Binlog 缓存会定期或在满足一定条件时（如缓存满了、事务提交等）将日志内容刷新到磁盘上的 Binlog 文件中。可以通过 `sync_binlog` 参数来控制刷新的频率，`sync_binlog = 0` 表示由操作系统决定何时将 Binlog 刷新到磁盘；`sync_binlog = 1` 表示每个事务提交时都将 Binlog 刷新到磁盘，保证了数据的安全性，但会增加磁盘 I/O 开销。

### 使用场景

  

- **主从复制**：在主从复制架构中，主服务器将 Binlog 发送给从服务器，从服务器通过解析和执行这些日志来同步主服务器的数据。这是 MySQL 实现读写分离、负载均衡和高可用性的基础。
- **数据恢复**：可以使用 `mysqlbinlog` 工具将 Binlog 文件解析成 SQL 语句，然后在目标数据库中执行这些语句，实现数据的增量恢复。例如，当数据库在某个时间点发生故障时，可以先使用全量备份恢复到故障前的状态，然后通过回放故障发生后产生的 Binlog 来恢复到最新状态。
- **数据审计**：通过分析 Binlog 可以了解数据库的变更历史，包括哪些用户在什么时间对哪些数据进行了修改，有助于进行安全审计和合规性检查。

### 管理和维护

  

- **日志轮换**：为了避免 Binlog 文件过大，MySQL 支持日志轮换功能。可以通过设置 `max_binlog_size` 参数来指定每个 Binlog 文件的最大大小，当文件达到该大小后，会自动创建一个新的 Binlog 文件。
- **日志清理**：随着时间的推移，Binlog 文件会越来越多，占用大量的磁盘空间。可以使用 `PURGE BINARY LOGS` 语句手动清理过期的 Binlog 文件，也可以通过设置 `expire_logs_days` 参数来自动清理指定天数之前的 Binlog 文件。

