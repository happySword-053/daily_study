# 一、什么是MVCC？
mvcc，也就是多版本并发控制，是为了在读取数据时不加锁来提高读取效率和并发性的一种手段。

数据库并发有以下几种场景：

- 读-读：不存在任何问题。
- 读-写：有线程安全问题，可能出现脏读、幻读、不可重复读。
- 写-写：有线程安全问题，可能存在更新丢失等。
mvcc解决的就是读写时的线程安全问题，线程不用去争抢读写锁。

mvcc所提到的读是**快照读**，也就是普通的select语句。快照读在读写时不用加锁，不过可能会读到历史数据。

还有一种读取数据的方式是**当前读**，是一种悲观锁的操作。它会对当前读取的数据进行加锁，所以读到的数据都是最新的。主要包括以下几种操作：

- select lock in share mode（共享锁）
- select for update（排他锁）
- update（排他锁）
- insert（排他锁）
- delete（排他锁）
# 二、MVCC的实现
## 1.回顾事务的特性

原子性：通过**undolog**实现。
持久性：通过**redolog**实现。
隔离性：通过加锁（当前读）&MVCC（快照读）实现。
一致性：通过undolog、redolog、隔离性共同实现。
## 2.回顾事务的隔离级别

读未提交：允许读取尚未提交的数据变更。可能会导致脏读、幻读或不可重复读。
读已提交：允许读取已经提交的数据。可能会导致幻读和不可重复读。
可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。可能会导致幻读。
可串行化：最高隔离级别。
在读已提交和可重复读隔离级别下的快照读，都是基于MVCC实现的！

# 3.mvcc实现原理
​ mvcc的实现，基于undolog、版本链、readview。
具体的实现是，在数据库的每一行中，添加额外的三个字段：

DB_TRX_ID – 记录插入或更新该行的最后一个事务的事务 ID
DB_ROLL_PTR – 指向该行对应的 undolog 的指针
DB_ROW_ID – 单调递增的行 ID，他就是 AUTO_INCREMENT 的主键 ID
![[Pasted image 20241205155426.png]]
![[Pasted image 20241205152818.png]]


### 什么是readview呢？

- **记录事务状态**：ReadView在事务首次执行SELECT时生成，记录以下关键信息：
    
    - `m_ids`：当前活跃（未提交）事务的ID列表。
        
    - `min_trx_id`：活跃事务中的最小ID（低水位线）。
        
    - `max_trx_id`：下一个即将分配的事务ID（高水位线）。
        
    - `creator_trx_id`：创建该ReadView的事务自身ID（仅当该事务有写操作时存在）。
        
- **可见性判断**：通过对比数据行的`DB_TRX_ID`（最后修改该行的事务ID）与ReadView的信息，决定当前事务能否看到该版本的数据：
    
    - 如果`DB_TRX_ID < min_trx_id`：该版本已提交，可见。
        
    - 如果`DB_TRX_ID >= max_trx_id`：该版本由未来事务修改，不可见。
        
    - 如果`min_trx_id <= DB_TRX_ID < max_trx_id`：需检查是否在`m_ids`中，若不在则可见。

![[Pasted image 20241205152724.png]]

## 对readview中的参数做一些解释

m_ids：活跃的事务就是指还没有commit的事务。

max_trx_id：例如m_ids中的事务id为（1，2，3），那么下一个应该分配的事务id就是4，max_trx_id就是4。

creator_trx_id：执行select读这个操作的事务的id。

readview如何判断版本链中的哪个版本可用呢？（重点！）
![[Pasted image 20241205152740.png]]


从上到下分别为（1）（2）（3）（4），依次进行解释

trx_id表示要读取的事务id

（1）如果要读取的事务id等于进行读操作的事务id，说明是我读取我自己创建的记录，那么为什么不可以呢。

（2）如果要读取的事务id小于最小的活跃事务id，说明要读取的事务已经提交，那么可以读取。

（3）max_trx_id表示生成readview时，分配给下一个事务的id，如果要读取的事务id大于max_trx_id，说明该id已经不在该readview版本链中了，故无法访问。

（4）m_ids中存储的是活跃事务的id，如果要读取的事务id不在活跃列表，那么就可以读取，反之不行。
![[Pasted image 20241205161601.png]]
如上图所示，有了上文提到的 TRX_ID 集合，就很容易判断这个问题了，如果这一行数据的 DB_TRX_ID 在 TRX_ID 集合中或大于当前事务的事务 ID，那么就说明这行数据是在当前事务开启后提交的，否则说明这行数据是在当前事务开启前提交的。
对于当前事务开启后提交的数据，当前事务需要通过隐藏的 DB_ROLL_PTR 字段找到 undo log，然后进行逻辑上的回溯才能拿到事务开启时的原数据。
这个通过 undo log + 数据行获取到事务开启时的原始数据的过程就是“快照读”。

### 4.mvcc如何实现RC和RR的隔离级别
（1）RC的隔离级别下，每个快照读都会生成并获取最新的readview。

（2）RR的隔离级别下，只有在同一个事务的第一个快照读才会创建readview，之后的每次快照读都使用的同一个readview，所以每次的查询结果都是一样的。
# 5. MVCC 与不可重复读、幻读的问题
## 5.1. 不可重复读与幻读
“不可重复读”与“幻读”是两个数据库常见的极易混淆的问题。
不可重复读指的是，在一个事务开启过程中，当前事务读取到了另一事务提交的修改。
幻读则指的是，在一个事务开启过程中，读取到另一个事务提交导致的数据条目的新增或删除。

## 5.2. 可重复读解决不可重复读与幻读问题的原理
那么，可重复读的隔离级别是否解决了不可重复读与幻读问题呢？
上面我们提到，对于正常的 select 查询 innodb 实际上进行的是快照读，即通过判断读取到的行的 DB_TRX_ID 与 DB_ROLL_PTR 字段指向的 undo log 回溯到事务开启前或当前事务最后一次更新的数据版本，从而在这样的场景下避免了可重复读与幻读的问题。
针对已存在的数据，insert 和 update 操作虽然是进行当前读，但 insert 与 update 操作后，该行的最新修改事务 ID 为当前事务 ID，因此读到的值仍然是当前事务所修改的数据，不会产生不可重复读的问题。
但如果当前事务更新到了其他事务新插入并提交了的数据，这就会造成该行数据的 DB_TRX_ID 被更新为当前事务 ID，此后即便进行快照读，依然会查出该行数据，产生幻读（其他事务插入或删除但未提交该行数据的情况下会锁定该行，造成当前事务对该行的更新操作被阻塞，所以这种情况不会产生幻读问题）
