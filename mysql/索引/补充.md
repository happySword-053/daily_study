# 1、聚簇索引和非聚簇索引
聚簇索引和非聚簇索引（也称为二级索引或辅助索引）是数据库索引中的重要概念，在 MySQL 等关系型数据库中广泛应用，下面分别详细介绍。

### 聚簇索引

#### 定义

  

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，表中数据行的物理存储顺序与聚簇索引的顺序是一致的，也就是说，聚簇索引的键值逻辑顺序决定了表中相应行的物理存储顺序。在一个表中，只能有一个聚簇索引。

#### 特点

  

- **数据与索引存储在一起**：聚簇索引将索引和数据行保存在同一个 B+ 树结构中。B+ 树的叶子节点包含了完整的数据记录，而不仅仅是索引键和指向数据的指针。
- **查询效率高**：对于按照聚簇索引键进行的范围查询、排序等操作，由于数据物理上是按索引顺序存储的，所以可以快速定位和访问数据，减少了磁盘 I/O 次数。
- **插入、更新、删除操作可能较慢**：因为数据的物理存储顺序与索引相关，当进行插入、更新、删除操作时，可能需要移动大量的数据来保持数据的有序性，从而增加了操作的开销。

#### 示例

  

在 MySQL 的 InnoDB 存储引擎中，会自动为主键创建聚簇索引。如果表没有显式定义主键，InnoDB 会选择一个唯一的非空索引代替；如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。

  

收起

sql

```
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT
);
```

  

在这个 `users` 表中，`id` 列是主键，InnoDB 会为 `id` 列创建聚簇索引，表中的数据会按照 `id` 的顺序进行物理存储。

### 非聚簇索引

#### 定义

  

非聚簇索引也称为二级索引或辅助索引，它的索引结构和数据存储是分离的。非聚簇索引的 B+ 树叶子节点存储的是索引键值和指向对应数据行的指针（在 InnoDB 中，这个指针实际上是聚簇索引的键值）。

#### 特点

  

- **索引和数据分离**：非聚簇索引有独立的 B+ 树结构，不影响数据行的物理存储顺序。
- **可以有多个**：一个表可以创建多个非聚簇索引，用于满足不同的查询需求。
- **可能需要回表操作**：当使用非聚簇索引进行查询时，如果查询的列不在非聚簇索引中，就需要通过索引中存储的指针回到聚簇索引中查找相应的数据行，这个过程称为回表操作，会增加查询的开销。

#### 示例

  

收起

sql

```
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    price DECIMAL(10, 2)
);

-- 创建非聚簇索引
CREATE INDEX idx_product_name ON products (product_name);
```

  

在这个 `products` 表中，`product_id` 是主键，会创建聚簇索引。同时，为 `product_name` 列创建了一个非聚簇索引 `idx_product_name`。当使用 `product_name` 进行查询时，会先在非聚簇索引中查找匹配的记录，然后根据索引中存储的 `product_id` 回到聚簇索引中获取完整的数据行。

### 两者对比

  

- **数据存储**：聚簇索引的数据和索引存储在一起，数据按索引顺序物理存储；非聚簇索引的索引和数据分离。
- **数量限制**：一个表只能有一个聚簇索引；可以有多个非聚簇索引。
- **查询性能**：聚簇索引对于范围查询和排序操作效率高；非聚簇索引如果需要回表操作，可能会影响查询性能。
- **增删改性能**：聚簇索引的增删改操作可能较慢，因为需要维护数据的物理顺序；非聚簇索引的增删改操作相对较快，但也需要更新索引结构。
- 
通常情况下，聚簇索引常基于主键来构建，而普通索引一般属于非聚簇索引。下面以 MySQL 的 InnoDB 存储引擎为例详细说明，并给出示例。

### 聚簇索引与主键

  

在 InnoDB 中，默认会为主键创建聚簇索引。这意味着数据行按照主键的顺序物理存储在磁盘上。

#### 示例表结构

  

收起

sql

```
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT
);
```

  

在这个 `students` 表中，`student_id` 被定义为主键。InnoDB 会自动为 `student_id` 创建聚簇索引，表中的数据行按照 `student_id` 的顺序物理排列在磁盘上。

#### 插入数据示例

  

收起

sql

```
INSERT INTO students (student_id, name, age) VALUES
(1, 'Alice', 20),
(2, 'Bob', 21),
(3, 'Charlie', 22);
```

  

数据在磁盘上会按照 `student_id` 的顺序存储，即 `student_id` 为 1 的行排在最前面，接着是 `student_id` 为 2 的行，最后是 `student_id` 为 3 的行。

#### 查询性能优势

  

当执行范围查询时，聚簇索引能体现出明显的性能优势。例如：

  

收起

sql

```
SELECT * FROM students WHERE student_id BETWEEN 1 AND 2;
```

  

由于数据按 `student_id` 顺序存储，数据库可以快速定位到 `student_id` 为 1 和 2 的行，减少磁盘 I/O 操作。

### 非聚簇索引与普通索引

  

普通索引是为了提高对表中特定列的查询速度而创建的，它属于非聚簇索引。非聚簇索引的索引结构和数据存储是分离的，索引的叶子节点存储的是索引键值和指向对应数据行的指针（在 InnoDB 中是主键值）。

#### 为已有表添加普通索引

  

收起

sql

```
CREATE INDEX idx_age ON students (age);
```

  

这里为 `students` 表的 `age` 列创建了一个普通索引 `idx_age`，它是非聚簇索引。

#### 查询示例及回表操作

  

收起

sql

```
SELECT * FROM students WHERE age = 21;
```

  

当执行这个查询时，数据库首先在 `idx_age` 非聚簇索引中查找 `age` 为 21 的记录，找到对应的主键值（这里是 `student_id`）。然后，通过主键值回到聚簇索引中查找完整的数据行，这个过程就是回表操作。

#### 覆盖索引优化

  

如果查询只需要索引列中的数据，就可以避免回表操作。例如：

  

收起

sql

```
SELECT age FROM students WHERE age = 21;
```

  

由于查询只需要 `age` 列的数据，而 `idx_age` 索引中已经包含了 `age` 列的值，数据库可以直接从索引中获取数据，无需回表，从而提高查询性能。

  

综上所述，在实际应用中，合理设计主键和普通索引，充分利用聚簇索引和非聚簇索引的特点，可以显著提高数据库的查询性能。

# 2、覆盖索引
覆盖索引（Covering Index）是数据库索引优化中的一个重要概念，能有效提升查询性能，下面从定义、工作原理、优点、使用条件和示例几个方面详细介绍：

### 定义

  

覆盖索引指的是一个查询语句的执行，只需要从索引中就能获取到所需的全部数据，而不必再回表到数据行中去查找其他信息。简单来说，索引 “覆盖” 了查询所需的数据。

### 工作原理

  

在数据库中，索引通常以 B+ 树等数据结构存储。当创建一个索引时，会在索引结构中存储索引列的值。对于覆盖索引，查询所需要的列都包含在该索引中。当执行查询时，数据库直接从索引中提取数据，而不需要再根据索引中的指针去数据文件里查找数据行，从而减少了磁盘 I/O 操作，提高查询效率。

### 优点

  

- **减少磁盘 I/O**：由于无需回表操作，避免了访问数据文件，减少了磁盘 I/O 次数，尤其是在磁盘 I/O 为性能瓶颈的系统中，能显著提升查询性能。
- **提高查询速度**：直接从索引中获取数据，无需额外的查找操作，查询速度更快。
- **降低 CPU 使用率**：减少了数据的读取和处理，降低了 CPU 的负担。

### 使用条件

  

- **查询列是索引列的子集**：查询语句中所涉及的列必须是索引列的一部分。也就是说，索引要包含查询所需的所有列。
- **合适的索引设计**：需要根据查询的需求来设计合适的索引，确保索引能够覆盖查询。

### 示例

  

假设有一个 `orders` 表，其表结构和数据插入语句如下：



```mysql
-- 创建 orders 表
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    amount DECIMAL(10, 2),
    INDEX idx_customer_order (customer_id, order_date, amount)
);

-- 插入示例数据
INSERT INTO orders (order_id, customer_id, order_date, amount)
VALUES 
(1, 101, '2024-01-01', 100.00),
(2, 102, '2024-01-02', 200.00),
(3, 101, '2024-01-03', 150.00);
```

  

在这个例子中，创建了一个复合索引 `idx_customer_order`，包含 `customer_id`、`order_date` 和 `amount` 三列。

  

以下查询就可以使用覆盖索引：

  

收起

sql

```
-- 查询 customer_id 为 101 的订单的订单日期和订单金额
SELECT order_date, amount 
FROM orders 
WHERE customer_id = 101;
```

  

在执行这个查询时，由于查询所需的 `order_date` 和 `amount` 列都包含在 `idx_customer_order` 索引中，数据库可以直接从索引中获取这些数据，而无需回表到数据行中查找，因此该索引覆盖了查询，提高了查询性能。

分享

覆盖索引一定比非覆盖索引查询效率高吗？

覆盖索引如何创建和使用？

索引对数据库的增删改操作有什么影响？