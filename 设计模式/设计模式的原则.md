1. **单一职责原则（Single Responsibility Principle, SRP）**： 一个类应该只有一个引起它变化的原因。换句话说，一个类只负责执行一个功能。
    
2. **开放封闭原则（Open/Closed Principle, OCP）**： 软件实体（类、模块、函数等）应该是对于扩展开放的，但是对于修改是封闭的。这意味着你可以通过添加新代码来扩展功能，但不需要改变已有的代码。
    
3. **里氏替换原则（Liskov Substitution Principle, LSP）**： 子类型必须能够替代其基类型；也就是说，程序中的对象实例可以被它的子类型的实例所替换而不会影响程序的正确性。
    
4. **接口隔离原则（Interface Segregation Principle, ISP）**： 客户端不应该被迫依赖于它们不使用的接口。当一个接口太大时，应该将其拆分成更小且具体的接口，这样客户端只需要知道它们感兴趣的方法。
    
5. **依赖倒置原则（Dependency Inversion Principle, DIP）**： 高层模块（稳定）不应该依赖低层模块（变化），两者都应该依赖抽象（稳定）。抽象（稳定）不应该依赖细节（变化），细节（变化）应该依赖抽象（稳定）。这有助于减少不同层次之间的耦合。
	```c++
	#include <iostream>
#include <memory>

// 抽象基类
class Notifier {
public:
    virtual ~Notifier() = default; // 虚析构函数确保派生类对象能够正确销毁
    virtual void send(const std::string& message) = 0; // 纯虚函数，定义接口
};

// 具体实现 - 邮件通知
class EmailNotifier : public Notifier {
public:
    void send(const std::string& message) override {
        std::cout << "Email sent: " << message << std::endl;
        // 发送邮件的逻辑
    }
};

// 具体实现 - 短信通知
class SmsNotifier : public Notifier {
public:
    void send(const std::string& message) override {
        std::cout << "SMS sent: " << message << std::endl;
        // 发送短信的逻辑
    }
};

// 高层模块
class NotificationService {
private:
    std::shared_ptr<Notifier> notifier; // 使用智能指针管理Notifier实例

public:
    // 依赖注入
    explicit NotificationService(std::shared_ptr<Notifier> notifier)
        : notifier(std::move(notifier)) {}

    void notifyUser(const std::string& message) {
        if (notifier) {
            notifier->send(message);
        }
    }
};

int main() {
    // 创建具体的通知器
    auto emailNotifier = std::make_shared<EmailNotifier>();
    auto smsNotifier = std::make_shared<SmsNotifier>();

    // 创建服务并注入不同的通知器
    NotificationService emailService(emailNotifier);
    NotificationService smsService(smsNotifier);

    // 使用服务发送通知
    emailService.notifyUser("Hello, this is an email notification.");
    smsService.notifyUser("Hello, this is an SMS notification.");

    return 0;
}
```
1. **迪米特法则/最少知识原则（Law of Demeter, LoD）**： 一个对象应当尽可能少地了解其他对象。通常也被称为“最少知识原则”，即一个单元不应与太多其他单元有关系。
    
7. **组合优于继承（Composition over Inheritance）**： 尽可能使用对象组合而不是类继承来达到复用的目的。这是因为继承会增加类之间的耦合度，而组合则提供了更大的灵活性。