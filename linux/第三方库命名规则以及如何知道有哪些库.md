### 1. 库文件的命名约定

在 Linux 系统中，动态链接库（Shared Library）和静态链接库（Static Library）有非常严格的命名约定：

#### **动态库 (Shared Libraries)**

- **命名格式：** `lib<name>.so.<version>`
    
- **链接名：** `lib<name>.so`
    
- **使用 `-l` 参数：** 当你使用 `-l<name>` 参数时，编译器会自动在库搜索路径中寻找 `lib<name>.so`。
    

例如：

- 实际文件名可能是：`libpthread.so.0` (带版本号)
    
- 符号链接名通常是：`libpthread.so`
    
- 你在 g++ 中使用的参数是：`-lpthread`
    

编译器会自动为你处理 `lib` 前缀和 `.so` 后缀。

#### **静态库 (Static Libraries)**

- **命名格式：** `lib<name>.a`
    
- **使用 `-l` 参数：** 同样是 `-l<name>`。
    

例如：

- 文件名是：`libboost_system.a`
    
- 你在 g++ 中使用的参数是：`-lboost_system`
    

如果同时存在静态库和动态库，编译器通常会优先选择动态库。你可以使用 `-static` 参数来强制链接静态库。

---

### 2. 如何知道库文件的名字？

你可以通过以下几种方法来确定一个库文件的名称，从而正确地使用 `-l` 参数。

#### **方法一：查看库的头文件或文档**

这是最直接、最可靠的方法。大多数优秀的开源库都会在它们的官方文档或教程中明确告诉你需要链接哪个库。

例如，如果你想使用 Boost 库，它的文档会告诉你需要链接 `libboost_system`、`libboost_thread` 等。

#### **方法二：使用 `pkg-config` (推荐)**

`pkg-config` 是一个非常方便的工具，它可以自动为你提供库的编译和链接参数。许多流行的库都支持它。

**用法：**

- **查看库信息：** `pkg-config --libs <module_name>`
    
- **获取编译和链接参数：**
    
    - `pkg-config --cflags <module_name>`：获取编译参数（如头文件路径 `-I`）。
        
    - `pkg-config --libs <module_name>`：获取链接参数（如库路径 `-L` 和库名 `-l`）。
        

**示例：** 如果你要使用 `libcurl` 库，你可以运行：


```Bash

pkg-config --cflags --libs libcurl
```

输出可能类似：

```Bash

-I/usr/include/curl -lcurl
```

这样你就知道应该在编译命令中添加 `-I/usr/include/curl` 和 `-lcurl` 了。

#### **方法三：使用 `find` 命令搜索**

如果你只知道库的名称或某个头文件，但不知道具体路径，可以用 `find` 命令来搜索。

**用法：**

- `find /usr/lib -name "*<library_name>*"`
    
- `find /usr/include -name "*<header_file>*.h"`
    

**示例：** 如果你想找 Boost 的库文件，可以这样搜索：

Bash

```
find /usr/lib -name "*boost_system*"
```

这会列出所有包含 `boost_system` 的库文件，如 `libboost_system.so.1.71.0`，你就能推断出库名是 `boost_system`。

#### **方法四：使用 `ldconfig -p`**

`ldconfig -p` 命令会列出系统缓存中所有可用的动态链接库及其对应的文件名。

**用法：** `ldconfig -p | grep <library_name>`

**示例：**



```Bash
ldconfig -p 
```

你会看到类似这样的输出：

```
	libboost_thread.so.1.71.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.71.0
	libboost_system.so.1.71.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libboost_system.so.1.71.0
```

这能让你一眼看出库的**实际文件名**和**版本号**。

---

### 3. 如何知道可执行文件依赖哪些库？

如果你拿到了一个已经编译好的可执行文件，想知道它运行时需要哪些动态库，可以使用 `ldd` 命令。

**用法：** `ldd <executable_file_path>`

**示例：**



```Bash
ldd /usr/bin/ls
```

输出会列出 `/bin/ls` 依赖的所有动态库，以及它们在系统中的实际路径：

```Bash
	linux-vdso.so.1 =>  (0x00007ffe34a9b000)
	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9c2d1b7000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9c2cfc5000)
	...
```

这个命令在排查**运行时库缺失**（"shared library not found"）问题时非常有用。